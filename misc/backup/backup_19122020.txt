
//console.log(CourseStatusLog['create']);
//console.log(CourseStatusLog);
//console.log(CourseStatusLog);
/* async udemyPurchase(data) {
    const { page, course } = data;
    await globalUtils.sleep(1000); // Insert to settings.js
    // Go to the course's page.
    await page.goto(course.udemyURL, this.pageOptions);
    await page.waitForFunction(this.waitForFunction, { timeout: this.timeout });
    await globalUtils.sleep(3000); // Insert to settings.js. Different variable, Wait for course page to load.
    // Validate if page exists.
    if (await page.$(domService.courseNotExistsDOM)) {
        // Change the status to NOT_EXISTS.
    }
    // Validate if the course exists.
    if (await page.$(domService.courseLimitAccessDOM)) {
        // Change the status to LIMIT_ACCESS.
    }
    // Validate if this is not course list suggestions.
    if (await page.$(domService.coursesSuggestListDOM)) {
        // Change the status to SUGGESTIONS_LIST.
    }
    // Validate that the course not already purchase.
    if (!await page.$(domService.coursePriceLabelDOM)) {
        // Change the status to ALREADY_PURCHASE.
    }
    const coursePriceLabel = await page.$eval(domService.coursePriceLabelDOM, el => el.textContent);
    if (!coursePriceLabel) {
        // Change the status to ALREADY_PURCHASE.
    }
    // Validate that the course is free.
    if (coursePriceLabel.indexOf('Free') === -1) {
        // Change course status to NOT_FREE.
    }
    // Get the course original price.
    const courseOriginalPriceLabel = await page.$eval(domService.courseOriginalPriceDOM, el => el.textContent);
    if (courseOriginalPriceLabel) {
        // Get the prices from the label and save them.
        const prices = courseUtils.getCoursePrices(courseOriginalPriceLabel);
    }
    // Validate that enroll button exists.
    const enrollButton = await page.$(domService.courseEnrollButtonDOM);
    if (!enrollButton) {
        // Change course status to ENROLL_NOT_EXISTS.
    }
    // Enroll the course and go to the checkout page.
    await globalUtils.sleep(1000); // Insert to settings.js
    await page.evaluate((courseEnrollButtonDOM) => {
        document.querySelector(courseEnrollButtonDOM).click();
    }, domService.courseEnrollButtonDOM);
    await page.waitForFunction(this.waitForFunction, { timeout: this.timeout });
    await globalUtils.sleep(3000); // Insert to settings.js. Different variable, Wait for checkout page to load.
    // Possible that is a course without checkout page. Validate it.
    if (await page.$(domService.purchaseSuccessDOM)) {
        // Course has no checkout page and has been purchased.
        // Change course status to PURCHASE.
    }
    // In the checkout page, Validate that the total price is 0.00.
    const checkoutPriceLabel = await page.$eval(domService.checkoutPriceDOM, el => el.textContent);
    if (!checkoutPriceLabel) {
        // Change course status to CHECKOUT_PRICE_NOT_EXISTS.
    }
    const { price } = courseUtils.getCoursePrices(checkoutPriceLabel);
    if (price > 0) {
        // Change course status to CHECKOUT_PRICE_NOT_FREE.
    }
    // Purchase the course.
    await page.evaluate((purchaseButtonDOM) => {
        document.querySelector(purchaseButtonDOM).click();
    }, domService.purchaseButtonDOM);
    await page.waitForFunction(this.waitForFunction, { timeout: this.timeout });
    await globalUtils.sleep(3000); // Insert to settings.js. Different variable, Wait for purchase success page to load.
    // Validate purchase success.
    if (await page.$(domService.purchaseSuccessDOM)) {
        // Course has been purchased.
        // Change course status to PURCHASE.
    }
    return page; */
/*     ['CART', 'CART'], */
/*     ['DISCOUNT', 'DISCOUNT'], */
    /*     ['INVALID', 'INVALID'], */
/*     ['NOT_EXISTS', 'NOT EXISTS'], */
/*     ['COURSES_LIST', 'COURSES LIST'], */
/*     ['VALIDATE', 'VALIDATE'], */
/*     ['UPDATE', 'UPDATE'], */

/*     ['UPDATE', 'UPDATE'],
    ['VALIDATE', 'VALIDATE'],
    ['LOG', 'LOG'], */
/*     ['', ''], */
/* //FETCH LINKS/PURCHASE COURSES */

    /* , UdemyData
}; */
/* const UdemyData = require('./files/UdemyData'); */

/* 		this.udemyCheckoutURL =  `${this.udemyBaseURL}/cart/checkout`; */
/* 		const { UDEMY_BASE_URL } = settings; */
/* 	setCrawlStart() {
		this.startDateTime = new Date();
	} */

    /*                         case 'n': resolve(false); break; */
/*         if (!settings.IS_PRODUCTION_MODE) {
            return true;
        } */


            //await puppeteerService.close();
//validationUtils
//        console.log(countLimitService);
       //await validationService.validateInternetConnection();
/* const settings = require('../settings/settings');
const { accountsService, applicationService, confirmationService, countLimitService,
    createEmailsService, logService, mongoDatabaseService, pathService, templatesService,
    sendEmailService, validationService } = require('../services');
const { Color, Status } = require('../core/enums');
const { globalUtils, logUtils, systemUtils } = require('../utils');

class SendLogic {

    constructor() {
        this.emailsData = null;
    }

    async run() {
        // Validate all settings are fit to the user needs.
        await this.confirm();
        // Initiate all the settings, configurations, services, ect.
        await this.initiate();
        // Validate general settings
        await this.validateGeneralSettings();
        // Start the sending emails processes.
        await this.startSession();
    }

    async initiate() {
        logUtils.logMagentaStatus('INITIATE THE SERVICES');
        applicationService.initiate(settings, Status.INITIATE);
        sendEmailService.initiate();
        countLimitService.initiate(settings);
        await mongoDatabaseService.initiate(settings);
        pathService.initiate(settings);
        await logService.initiate(settings);
        await accountsService.initiate();
        templatesService.initiate();
        this.emailsData = await createEmailsService.initiate(settings);
    }

    async validateGeneralSettings() {
        logUtils.logMagentaStatus('VALIDATE GENERAL SETTINGS');
        if (!applicationService.applicationData.isProductionMode) {
            return;
        }
        // Validate internet connection works.
        await validationService.validateInternetConnection();
        // Validate that the mode is PRODUCTION and both send and save emails flags marked as true.
        if (!applicationService.applicationData.isSendEmails || !applicationService.applicationData.isSaveEmails) {
            throw new Error('Production mode but isSendEmails or isSaveEmails flags are false (1000004)');
        }
    }

    async startSession() {
        // Initiate.
        applicationService.applicationData.startDateTime = new Date();
        if (!applicationService.applicationData.isLogMode) {
            logService.startLogProgress();
        }
        await this.pause();
        // Loop the emails and process them.
        for (let i = 0; i < this.emailsData.emailsList.length; i++) {
            // Start the process of sending email.
            applicationService.applicationData.currentEmailIndex = i;
            const emailData = this.emailsData.emailsList[i];
            const { isRetrySend, exitProgramStatus } = await this.send(emailData);
            // Log results.
            this.log(emailData);
            await logService.logResult(emailData);
            // Pause between each emails here.
            await this.pause();
            // Exit the program if needed.
            if (exitProgramStatus) {
                await this.exit(exitProgramStatus, Color.RED);
                break;
            }
            // Check if need to retry to send the email.
            if (isRetrySend) {
                this.emailsData.emailsList[i] = createEmailsService.resetEmail(emailData);
                i--;
                applicationService.applicationData.currentEmailIndex = i;
            }
        }
        await this.exit(Status.FINISH, Color.GREEN);
    }

    async sleep() {
        await globalUtils.sleep(countLimitService.countLimitData.millisecondsSendEmailDelayCount);
    }

    async send(emailData) {
        applicationService.applicationData.status = Status.SEND;
        await this.sleep();
        return await sendEmailService.runEmailProcess(emailData);
    }

    async pause() {
        applicationService.applicationData.status = Status.PAUSE;
        await this.sleep();
    }

    log(emailData) {
        if (applicationService.applicationData.isLogMode) {
            logUtils.log(logService.createEmailTemplate(emailData, false));
        }
    }

    // Let the user confirm all the IMPORTANT settings before the process start.
    async confirm() {
        if (!await confirmationService.confirm(settings)) {
            this.exit('EXIT: ABORTED BY THE USER', Color.RED);
        }
    }

    async exit(status, color) {
        if (applicationService.applicationData) {
            applicationService.applicationData.status = status;
            await this.sleep();
            logService.close();
        }
        systemUtils.exit(status, color);
    }
}

module.exports = SendLogic; */

/* const coursesService = require('./files/courses.service'); */
/* coursesService,  */

/*         this.isCoursesList = null; */
/*         this.isCoursesList = false; */

/* Method, */
/*             // Log the course.
            await logCourse({
                course: course,
                method: Method.GET_COURSES,
                isValid: course.status === CourseStatus.CREATE
            }); */
/* const logService = require('./log.service'); */
/* const udemyService = require('./udemy.service'); */
/* debugger;
debugger; */
/*         course = courseUtils.updateCourseStatus({
            course: course,
            status: CourseStatus.COURSES_LIST,
            details: 'This is an courses list page, not an acutal course.'
        }); */
/*         debugger; */
/* logCourse */
/*         course = courseUtils.updateCourseStatus(course, CourseStatus.COURSES_LIST, 'This is an courses list page, not an acutal course.'); */
/*                 this.coursesData.coursesList[i] = courseUtils.updateCourseStatus(currentCourse, CourseStatus.DUPLICATE,
                    'This course repeats multiple times in this session and should be purchased.'); */
                //this.coursesData.coursesList[i] = courseUtils.updateCourseStatus(course, scanFieldsResult.status, scanFieldsResult.details);
            //await logGetCourse(course.status === CourseStatus.CREATE);
                //this.coursesData.coursesList[i] = updatedStatus;
            //const { id, status, udemyURLCompare } = this.coursesData.coursesList[i];
                //this.coursesData.coursesList[i].status = CourseStatus.DUPLICATE;
/*                 scanFieldsResult = {
    status: CourseStatus.MISSING_FIELD,
    details: `Field ${key} should not be empty, but not contains any value.`
}; */
            //return CourseStatus.INVALID;
                    //scanFieldsResult = CourseStatus.UNEXPECTED_FIELD;
        //course.status = CourseStatus.COURSES_LIST;
/*             -Finalize step: Loop on all courses and:
-If no udemyURL found - Mark status as MISSING_URL.
-If the udemyURL is invalid - Mark status as INVALID.
-Do a comperation step, to make sure no duplicate course will be inserted.
-Log the entire object - Post id (if exists), course name, page URL, Udemy URL, course coupon. */
/*     for (let y = 0; y < list.length; y++) {
        const currentURL = list[y];
        if (currentURL.status !== CourseStatus.CREATE) {
            continue;
        }
        for (let i = 0; i < list.length; i++) {
            const { id, status, url } = list[i];
            if (currentURL.id === id || status !== CourseStatus.CREATE) {
                continue;
            }
            if (currentURL.url === url) {
                list[i].status = CourseStatus.DUPLICATE;
            }
        }
    } */
//        course.status = CourseStatus.CREATE;
/*         const { id, postId, creationDateTime, pageNumber, publishDate, priceNumber, courseURLCourseName, udemyURLCourseName,
            type, isFree, courseURL, udemyURL, couponKey, status, resultDateTime, resultDetails } = course; */

        //course.isCoursesList = true;
/*         if (courseData.type !== 'SINGLE') {
            console.log(courseData);
        } */
/*         course.status = CourseStatus.UPDATE; */
/*         course.status = CourseStatus.UPDATE; */
/*         course.type = CourseType.SINGLE; */
/*                 course.udemyURL = result.url;
        course.couponKey = result.couponKey;
        courseService.coursesData.coursesList[courseIndex] = course; */
        //console.log(course);
/* const puppeteerService = require('./puppeteer.service'); */
/*     async createCourses() {
        await puppeteerService.createCourses();
    } */
//const { validationUtils } = require('../../utils');
/*     updateCourses(courses) {
        if (validationUtils.isExists(courses)) {
            this.coursesData.coursesList = [...this.coursesData.coursesList, ...courses];
        }
    }
 */

 /* Method, */
/*                 method: Method.GET_COURSES, */
/* logService.logCourse.call(this) */
/* const { validationUtils } = require('../../utils'); */
        // Log the courses in this step.
        //logService.logGetCourses();
/* for (let i = 0; i < courseService.coursesData.coursesList.length; i++) {
    console.log(courseService.coursesData.coursesList[i]);
} */
/*         console.log(courseService.coursesData.coursesList.length); */
        //debugger;
/* const { CourseData, CoursesData } = require('../../core/models'); */
/*         this.coursesData = new CoursesData(); */
/*     createCourse(course) {
        this.coursesData.coursesList.push(new CourseData(course));
        console.log(course);
    } */
//const { validationUtils } = require('../../utils');
/*     updateCourses(courses) {
        if (validationUtils.isExists(courses)) {
            this.coursesData.coursesList = [...this.coursesData.coursesList, ...courses];
        }
    }
 */

 //Status, Color,
                    //systemUtils.exit(Status.GET_ERROR_IN_A_ROW, Color.RED, 0);
            //}
            //) {
/* mainContent, pageNumber */
        //this.loginEmail2DOM = '#email--1';
//
        //#id_email') === null || await page.$('#id_password'
                    //courseURLsList: dom.window.document.getElementsByTagName('a')
        //const urls = dom.window.document.getElementsByTagName('a');
            //const coursesDOMList = dom.window.document.getElementsByClassName('amz-deal');
//const udemyService = require('./udemy.service');
            //if (url.indexOf(udemyService.udemyData.udemyBaseURL) > -1) {
/*     isValidateUdemyURL(udemyURL) {
        return udemyURL && udemyURL.indexOf(udemyService.udemyData.udemyBaseURL) > -1;
    } */
                        //this.singleCourseDateDOM
            //const date = timeUtils.getDateFromString(course.getElementsByClassName('meta')[0]?.childNodes[2]?.data?.trim());
                        //const date = timeUtils.getDateFromString(dom.window.document.getElementsByClassName('meta')[0]?.childNodes[2]?.data?.trim());
            //const url = course.getElementsByClassName('grid-tit')[0]?.childNodes[0];
        //const courses = dom.window.document.querySelectorAll('[id^="post-"]');
    //udemyService
    //if (url.indexOf(applicationService.applicationData.udemyBaseURL) > -1) {

/*     isValidateUdemyURL(udemyURL) {
        return udemyURL && udemyURL.indexOf(applicationService.applicationData.udemyBaseURL) > -1;
    } */
/*             if (!udemyURL || udemyURL.indexOf(applicationService.applicationData.udemyBaseURL) === -1) {
continue;
} */
/*             if (!udemyURL) {
                continue;
            } */
                        //debugger;
            //console.log(1);
/*             const courseURLsList = dom.window.document.getElementsByTagName('a'); */
/* if (validationUtils.isExists(courseURLsList)) */
/*     async getCoursesList(coursesLists) {
        for (let i = 0; i < coursesLists.length; i++) {
            const { course, courseIndex, dom } = coursesLists[i];
            const coursesDOMList = dom.window.document.getElementsByClassName('amz-deal');
            const date = timeUtils.getDateFromString(dom.window.document.getElementsByClassName('meta')[0]?.childNodes[2]?.data?.trim());
            for (let y = 0; y < coursesDOMList.length; y++) {
                const innerCourse = coursesDOMList[y];
                const url = innerCourse.getElementsByClassName('course_title')[0];
                const udemyURL = url?.href;
                const couponKey = courseUtils.getCourseCoupon(udemyURL);
                courseService.createCourse({
                    postId: null,
                    pageNumber: course.pageNumber,
                    isFree: !validationUtils.isExists(couponKey),
                    courseURL: course.courseURL,
                    udemyURL: udemyURL,
                    couponKey: courseUtils.getCourseCoupon(udemyURL),
                    courseURLCourseName: url?.text,
                    publishDate: date,
                    isSingleCourse: false
                });
                await globalUtils.sleep(countLimitService.countLimitData.millisecondsTimeoutBetweenCoursesCreate);
            }
            courseService.updateCoursesListCourseData({
                course: course,
                courseIndex: courseIndex
            });
        }
    } */

        //console.log(courseService.coursesData.coursesList.find(c => c.type !== 'SINGLE'));
/*                 course.isCoursesList = true; */
/*                 postId: parseInt(course.id.split('-')[1]),
                pageNumber: pageNumber,
                url: url?.href,
                name: url?.text,
                publishDate: date,
                isSingleCourse: true */
                                    //await globalUtils.sleep(countLimitService.countLimitData.millisecondsTimeoutBetweenCoursesUpdate);
/*             this.millisecondsTimeoutBetweenCoursesCreate = MILLISECONDS_TIMEOUT_BETWEEN_COURSES_CREATE;
            this.millisecondsTimeoutBetweenCoursesMainPages = MILLISECONDS_TIMEOUT_BETWEEN_COURSES_MAIN_PAGES;
            this.millisecondsTimeoutBetweenCoursesUpdate = MILLISECONDS_TIMEOUT_BETWEEN_COURSES_UPDATE; */
        //return course;
        //const course = courseService.coursesData.coursesList.find(c => c.id === courseId);
/*             createCoursesService.createCourse({
                id: course.id.split('-')[1],
                courseURL: url?.href,
                name: url?.text,
                publishDate: date
            }); */
//const createCoursesService = require('./createCourses.service');
            //console.log(createCoursesService);
            //id, courseURL, name, publishDate
/*         const list = []; */
/*         return list; */
/*                 console.log(result); */
        //console.log(list);
                    //console.log(post.getElementsByClassName('grid-tit')[0]?.childNodes[0]?.href);
        //console.log(list);
                    //const date =
                    //console.log(date.trim());
                    //debugger;
                    //console.log(title);
                    //debugger;
                    //console.log(posts[i]);
/*         console.log(dom); */
        //console.log(posts);
        //debugger;
        //console.log(posts);

        /* 			// ===GENERAL=== //
			'SPECIFIC_COURSES_PAGE_NUMBER', */

            		/* method, */
				/*
		===[SETTINGS] Method: GET COURSES/PURCHASE COURSES | Query Date: 2020/12/06 | Specific Page Number: ## | Is Key Words Filter: false===
		===[GENERAL] Time: 00.05:16:58 [-] | Total Price Purchase: ₪5,450 | Course: 2/348 (48%) | Status: GET COURSES/VALIDATE/PAUSE/NO URLS/LOGIN/ADD CART/CHECKOUT/SUCCESS===
		===[PROCESS1] Purchase: ✅ 0 | Fail: ❌ 0 | Filter: 0 | Missing Field: 0 | Unexpected Field: 0 | Duplicate: 0===
		===[PROCESS2] Get Error: 0 | Empty URL: 0 | Not Exists: 0 | Limit Access: 0 | Suggestions List: 0 | Already Purchase: 0===
		===[PROCESS3] Course Price Not Free: 0 | Enroll Not Exists: 0 | Checkout Price Not Exists: 0===
		===[PROCESS4] Checkout Price Not Free: 0 | Purchase Error: 0===
		===[DATA1] Creation: 12/12/2020 18:02:00 | Id: 33444 | Post Id: 4323 | Status: CREATE/INVALID/ERROR/NOT_EXISTS/VALIDATE/CART/PURCHASE_FAIL/PURCHASE
		===[DATA2] Publish Date: 13/12/2020 | Page Number: 3 | Index Page Number: 4===
		===[DATA3] Is Free: false | Price Display: ₪450.00 | Coupon Key: A1C8F6566F1EA8D253AC | Type: SINGLE/COURSES LIST===
		===[ERRORS] Get Error In A Row: 0 | Purchase Error In A Row: 0===
		===[NAME] Learn How to Setup Online Exports Business Instantly (cut it to maximum characters)===
		===[COURSE URL] https://idownloadcoupon.com/2020/12/17/amazon-aws-sysops-administrator-associate-certificate-tests/ (cut it to maximum characters)===
		===[UDEMY URL] https://www.udemy.com/course/learn-python-coding-from-basic-beginning-to-master/?couponCode=DECEMBER-BONANZA (cut it to maximum characters)===
		===[RESULT] Time: 12/12/2020 18:02:00 | Result: The course has been purchased successfully. (cut it to maximum characters)===
		*/

		/* 		const time = `${applicationService.applicationData.time} [${this.frames[this.i = ++this.i % this.frames.length]}]`;
				const currentPercentage = textUtils.calculatePercentageDisplay({ partialValue: applicationService.applicationData.currentEmailIndex, totalValue: sendEmailService.sendEmailsData.totalPendingCount });
				const current = textUtils.getNumberOfNumber({ number1: applicationService.applicationData.currentEmailIndex, number2: sendEmailService.sendEmailsData.totalPendingCount });
				const currentItem = `${current} (${currentPercentage})`;
				const available = textUtils.getNumberWithCommas(accountsService.accountsData.availableSendsCount);
				const total = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.totalCount);
				const pending = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.pendingCount);
				const sent = `${StatusIcon.V}  ${textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.sentCount)}`;
				const error = `${StatusIcon.X}  ${textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.errorCount)}`;
				const exists = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.existsCount);
				const database = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.databaseCount);
				const save = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.saveCount);
				const invalid = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.invalidCount);
				const duplicate = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.duplicateCount);
				const filter = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.filterCount);
				const skip = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.skipCount);
				const unsave = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.unsaveCount);
				const identicalAddresses = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.identicalAddressesCount);
				const monitorSent = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.monitorSentCount);
				const securityError = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.securityErrorCount);
				const securityExists = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.securityExistsCount);
				const missingField = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.missingFieldCount);
				const invalidStatus = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.invalidStatusCount);
				const identicalStatus = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.identicalStatusCount);
				const unexpectedField = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.unexpectedFieldCount);
				const sendErrorInARowCount = textUtils.getNumberWithCommas(sendgridService.sendErrorInARowCount);
				const saveErrorInARowCount = textUtils.getNumberWithCommas(mongoDatabaseService.saveErrorInARowCount);
				const accountSentPercentage = textUtils.calculatePercentageDisplay({
					partialValue: accountsService.accountData.sentCount,
					totalValue: countLimitService.countLimitData.maximumSendGridDailyEmailsCount
				});
				const accountSent = textUtils.getNumberOfNumber({
					number1: accountsService.accountData.sentCount,
					number2: countLimitService.countLimitData.maximumSendGridDailyEmailsCount
				});
				const accountSentItem = `${accountSent} (${accountSentPercentage})`;
				const accounts = textUtils.getNumberOfNumber({ number1: accountsService.accountsData.currentAccountIndex, number2: accountsService.accountsData.accountsList.length });
				let subjectId = this.noneValue;
				let subjectLineDisplay = this.noneValue;
				let textId = this.noneValue;
				let textLineDisplay = this.noneValue;
				let filePath = this.noneValue;
				if (templatesService.templateData) {
					subjectId = templatesService.templateData.subjectId;
					subjectLineDisplay = templatesService.templateData.subjectLineDisplay;
					textId = templatesService.templateData.textId;
					textLineDisplay = templatesService.templateData.textLineDisplay;
				}
				if (templatesService.cvData) {
					filePath = templatesService.cvData.filePath;
				}
				let resultCode = this.noneValue;
				let status = this.noneValue;
				let step = this.noneValue;
				let fromEmailAddress = this.noneValue;
				let toEmailAddress = this.noneValue;
				let id = this.noneValue;
				let type = this.noneValue;
				let resultDetails = this.noneValue;
				if (sendEmailService.emailData) {
					resultCode = sendEmailService.emailData.resultCode;
					status = this.getDisplayStatus(sendEmailService.emailData.status);
					step = sendEmailService.emailData.step;
					fromEmailAddress = this.getDisplayEmailAddress(sendEmailService.emailData.fromEmailAddress);
					toEmailAddress = this.getDisplayEmailAddress(sendEmailService.emailData.toEmailAddress);
					id = sendEmailService.emailData.id;
					type = sendEmailService.emailData.type;
					if (sendEmailService.emailData.resultDetails) {
						resultDetails = textUtils.cutText({ text: sendEmailService.emailData.resultDetails.join(' '), count: countLimitService.countLimitData.maximumResultCharactersDisplayCount });
					}
				}
				logUtils.logProgress({
					titlesList: ['SETTINGS', 'GENERAL', 'PROCESS1', 'PROCESS2', 'PROCESS3', 'PROCESS4',
						'ACCOUNT', 'API KEY', 'TEMPLATE', 'ATTACHMENT', 'SEND', 'RESULT'],
					colorsTitlesList: [Color.BLUE, Color.BLUE, Color.BLUE, Color.BLUE, Color.BLUE, Color.BLUE,
					Color.BLUE, Color.BLUE, Color.BLUE, Color.BLUE, Color.BLUE, Color.BLUE],
					keysLists: [{
						'Mode': applicationService.applicationData.mode,
						'Method': applicationService.applicationData.method,
						'Database': mongoDatabaseService.mongoDatabaseData.mongoDatabaseModeName,
						'Drop': mongoDatabaseService.mongoDatabaseData.isDropCollection
					}, {
						'Time': time,
						'Current': currentItem,
						'Available': available,
						'Status': applicationService.applicationData.status
					}, {
						'Total': total,
						'Pending': pending,
						'Sent': sent,
						'Error': error,
						'Exists': exists,
						'Database': database
					}, {
						'Save': save,
						'Invalid': invalid,
						'Duplicate': duplicate,
						'Filter': filter,
						'Skip': skip,
						'Unsave': unsave,
						'Identical Addresses': identicalAddresses
					}, {
						'Monitor Sent': monitorSent,
						'Security Error': securityError,
						'Security Exists': securityExists,
						'Missing Field': missingField,
						'Invalid Status': invalidStatus
					}, {
						'Identical Status': identicalStatus,
						'Unexpected Field': unexpectedField,
						'Sent Error In A Row': sendErrorInARowCount,
						'Save Error In A Row': saveErrorInARowCount
					}, {
						'Id': accountsService.accountData.id,
						'Username': accountsService.accountData.username,
						'Sent': accountSentItem,
						'Accounts': accounts
					}, {
						'#': accountsService.accountData.apiKey
					}, {
						[`Subject (Id: ${subjectId})`]: subjectLineDisplay,
						[`Text (Id: ${textId})`]: textLineDisplay
					}, {
						'#': filePath
					}, {
						'Code': resultCode,
						'Status': status,
						'Step': step,
						'From': fromEmailAddress,
						'To': toEmailAddress,
						'Id': id,
						'Type': type
					}, {
						'#': resultDetails
					}],
					colorsLists: [
						[Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW],
						[Color.YELLOW, Color.YELLOW, Color.CYAN, Color.YELLOW],
						[Color.CYAN, Color.CYAN, Color.GREEN, Color.RED, Color.CYAN, Color.CYAN],
						[Color.GREEN, Color.RED, Color.CYAN, Color.CYAN, Color.CYAN, Color.RED, Color.CYAN],
						[Color.CYAN, Color.RED, Color.RED, Color.RED, Color.RED],
						[Color.RED, Color.RED, Color.RED, Color.RED, Color.RED],
						[Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW],
						[],
						[Color.YELLOW, Color.YELLOW],
						[],
						[Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW],
						[]
					],
					statusColor: Color.CYAN
				}); */

                				//course = ``
								//const courseIndex = `${textUtils.getNumberWithCommas(courseService.coursesData.courseIndex)}/${textUtils.getNumberWithCommas(courseService.coursesData.coursesList.length)}`;
/* 			const { time, minutes } = timeUtils.getDifferenceTimeBetweenDates({
				startDateTime: applicationService.applicationData.startDateTime,
				endDateTime: new Date()
			});
			applicationService.applicationData.time = time; */
/* 			applicationService.applicationData.minutesCount = minutes; */
/*
'COURSES_BASE_URL', 'UDEMY_BASE_URL', 'SINGLE_COURSE_INIT', 'COURSES_DATE, SPECIFIC_COURSES_PAGE_NUMBER',
'KEY_WORDS_FILTER_LIST', 'IS_GET_COURSES_METHOD_ACTIVE', 'IS_PURCHASE_COURSES_METHOD_ACTIVE',
'IS_LOG_GET_COURSES_VALID', 'IS_LOG_GET_COURSES_INVALID', 'IS_LOG_PURCHASE_COURSES_VALID',
'IS_LOG_PURCHASE_COURSES_INVALID', 'MAXIMUM_COURSES_PURCHASE_COUNT', 'MAXIMUM_PAGES_NUMBER' */
//		debugger;
		//debugger;
		//debugger;
		// add flags for each type of courses.
/* 		if (!applicationService.applicationData.isLogResults) {
			return;
		} */
		// add flags for each type of courses.
/*
Time: 15:05:43 | Id: 334 | Creation Date Time: 12/08/2020 15:04:34 | Page Number: 2 | Publis Date: 2020/12/08
Name: Time Management for Professionals
Type: COURSES LIST | Is Free: false | Coupon Key: BD1F9BF485081A1F438B | Status: CREATE
Page URL: https://idownloadcoupon.com/2020/12/08/free-udemy-courses-list-9-18-2020/
Udemy URL: https://www.udemy.com/course/time-management-for-professionals/?couponCode=BD1F9BF485081A1F438B
*/

/* 	getDisplayEmailAddress(emailAddress) {
	return textUtils.cutText({ text: emailAddress, count: countLimitService.countLimitData.maximumEmailAddressCharactersDisplayCount });
} */
/* 	const Method = enumUtils.createEnum([
['GET_COURSES', 'GET COURSES'],
['PURCHASE_COURSES', 'PURCHASE COURSES']
]); */

				//this.emailResultsPath = this.createFilePath(`email_results_${Placeholder.DATE}`);


/* const { fileUtils, pathUtils, logUtils, mongoDatabaseUtils, textUtils, timeUtils, validationUtils } = require('../../utils');
const { Color, EmailAddressStatus, StatusIcon, Placeholder } = require('../../core/enums');
const { LogData } = require('../../core/models/application');
const accountsService = require('./accounts.service');
const applicationService = require('./application.service');
const countLimitService = require('./countLimit.service');
const mongoDatabaseService = require('./mongoDatabase.service');
const pathService = require('./path.service');
const sendEmailService = require('./sendEmail.service');
const sendgridService = require('./sendgrid.service');
const templatesService = require('./templates.service');

class LogService {

	constructor() {
		this.logData = null;
		this.logInterval = null;
		// ===PATH=== //
		this.baseSessionPath = null;
		this.sessionDirectoryPath = null;
		this.emailResultsPath = null;
		this.frames = ['-', '\\', '|', '/'];
		this.i = 0;
		this.noneValue = '##';
		this.logSeperator = '==========';
	}

	async initiate(settings) {
		this.logData = new LogData(settings);
		await this.initiateDirectories();
	}

	async initiateDirectories() {
		// ===PATH=== //
		if (!applicationService.applicationData.isLogResults) {
			return;
		}
		await this.createModeDirectory();
		await this.createSessionDirectory();
		this.emailResultsPath = this.createFilePath(`email_results_${Placeholder.DATE}`);
	}

	startLogProgress() {
		// Start the process for the first interval round.
		this.logInterval = setInterval(() => {
			// Update the current time of the process.
			const { time, minutes } = timeUtils.getDifferenceTimeBetweenDates({
				startDateTime: applicationService.applicationData.startDateTime,
				endDateTime: new Date()
			});
			applicationService.applicationData.time = time;
			applicationService.applicationData.minutesCount = minutes;
			// Log the status console each interval round.
			this.logProgress();
		}, countLimitService.countLimitData.millisecondsIntervalCount);
	}

	getNextDirectoryIndex() {
		const directories = fileUtils.getAllDirectories(this.baseSessionPath);
		if (!validationUtils.isExists(directories)) {
			return 1;
		}
		return Math.max(...directories.map(name => textUtils.getSplitNumber(name))) + 1;
	}

	async createModeDirectory() {
		this.baseSessionPath = pathUtils.getJoinPath({
			targetPath: pathService.pathData.distPath,
			targetName: textUtils.toLowerCase(applicationService.applicationData.mode)
		});
		await fileUtils.createDirectory(this.baseSessionPath);
	}

	async createSessionDirectory() {
		this.sessionDirectoryPath = pathUtils.getJoinPath({
			targetPath: this.baseSessionPath,
			targetName: `${this.getNextDirectoryIndex()}_${applicationService.applicationData.logDateTime}`
		});
		await fileUtils.createDirectory(this.sessionDirectoryPath);
	}

	createFilePath(fileName) {
		const isDate = fileName.indexOf(Placeholder.DATE) > -1;
		return pathUtils.getJoinPath({
			targetPath: this.sessionDirectoryPath ? this.sessionDirectoryPath : pathService.pathData.distPath,
			targetName: `${isDate ? fileName.replace(Placeholder.DATE, applicationService.applicationData.logDateTime) : fileName}.txt`
		});
	}

	getDisplayStatus(status) {
		return sendEmailService.emailAddressStatusKeys.find(key => EmailAddressStatus[key] === status);
	}

	getDisplayEmailAddress(emailAddress) {
		return textUtils.cutText({ text: emailAddress, count: countLimitService.countLimitData.maximumEmailAddressCharactersDisplayCount });
	}

	logProgress() {
		const time = `${applicationService.applicationData.time} [${this.frames[this.i = ++this.i % this.frames.length]}]`;
		const currentPercentage = textUtils.calculatePercentageDisplay({ partialValue: applicationService.applicationData.currentEmailIndex, totalValue: sendEmailService.sendEmailsData.totalPendingCount });
		const current = textUtils.getNumberOfNumber({ number1: applicationService.applicationData.currentEmailIndex, number2: sendEmailService.sendEmailsData.totalPendingCount });
		const currentItem = `${current} (${currentPercentage})`;
		const available = textUtils.getNumberWithCommas(accountsService.accountsData.availableSendsCount);
		const total = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.totalCount);
		const pending = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.pendingCount);
		const sent = `${StatusIcon.V}  ${textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.sentCount)}`;
		const error = `${StatusIcon.X}  ${textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.errorCount)}`;
		const exists = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.existsCount);
		const database = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.databaseCount);
		const save = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.saveCount);
		const invalid = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.invalidCount);
		const duplicate = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.duplicateCount);
		const filter = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.filterCount);
		const skip = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.skipCount);
		const unsave = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.unsaveCount);
		const identicalAddresses = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.identicalAddressesCount);
		const monitorSent = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.monitorSentCount);
		const securityError = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.securityErrorCount);
		const securityExists = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.securityExistsCount);
		const missingField = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.missingFieldCount);
		const invalidStatus = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.invalidStatusCount);
		const identicalStatus = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.identicalStatusCount);
		const unexpectedField = textUtils.getNumberWithCommas(sendEmailService.sendEmailsData.unexpectedFieldCount);
		const sendErrorInARowCount = textUtils.getNumberWithCommas(sendgridService.sendErrorInARowCount);
		const saveErrorInARowCount = textUtils.getNumberWithCommas(mongoDatabaseService.saveErrorInARowCount);
		const accountSentPercentage = textUtils.calculatePercentageDisplay({
			partialValue: accountsService.accountData.sentCount,
			totalValue: countLimitService.countLimitData.maximumSendGridDailyEmailsCount
		});
		const accountSent = textUtils.getNumberOfNumber({
			number1: accountsService.accountData.sentCount,
			number2: countLimitService.countLimitData.maximumSendGridDailyEmailsCount
		});
		const accountSentItem = `${accountSent} (${accountSentPercentage})`;
		const accounts = textUtils.getNumberOfNumber({ number1: accountsService.accountsData.currentAccountIndex, number2: accountsService.accountsData.accountsList.length });
		let subjectId = this.noneValue;
		let subjectLineDisplay = this.noneValue;
		let textId = this.noneValue;
		let textLineDisplay = this.noneValue;
		let filePath = this.noneValue;
		if (templatesService.templateData) {
			subjectId = templatesService.templateData.subjectId;
			subjectLineDisplay = templatesService.templateData.subjectLineDisplay;
			textId = templatesService.templateData.textId;
			textLineDisplay = templatesService.templateData.textLineDisplay;
		}
		if (templatesService.cvData) {
			filePath = templatesService.cvData.filePath;
		}
		let resultCode = this.noneValue;
		let status = this.noneValue;
		let step = this.noneValue;
		let fromEmailAddress = this.noneValue;
		let toEmailAddress = this.noneValue;
		let id = this.noneValue;
		let type = this.noneValue;
		let resultDetails = this.noneValue;
		if (sendEmailService.emailData) {
			resultCode = sendEmailService.emailData.resultCode;
			status = this.getDisplayStatus(sendEmailService.emailData.status);
			step = sendEmailService.emailData.step;
			fromEmailAddress = this.getDisplayEmailAddress(sendEmailService.emailData.fromEmailAddress);
			toEmailAddress = this.getDisplayEmailAddress(sendEmailService.emailData.toEmailAddress);
			id = sendEmailService.emailData.id;
			type = sendEmailService.emailData.type;
			if (sendEmailService.emailData.resultDetails) {
				resultDetails = textUtils.cutText({ text: sendEmailService.emailData.resultDetails.join(' '), count: countLimitService.countLimitData.maximumResultCharactersDisplayCount });
			}
		}
		logUtils.logProgress({
			titlesList: ['SETTINGS', 'GENERAL', 'PROCESS1', 'PROCESS2', 'PROCESS3', 'PROCESS4',
				'ACCOUNT', 'API KEY', 'TEMPLATE', 'ATTACHMENT', 'SEND', 'RESULT'],
			colorsTitlesList: [Color.BLUE, Color.BLUE, Color.BLUE, Color.BLUE, Color.BLUE, Color.BLUE,
			Color.BLUE, Color.BLUE, Color.BLUE, Color.BLUE, Color.BLUE, Color.BLUE],
			keysLists: [{
				'Mode': applicationService.applicationData.mode,
				'Method': applicationService.applicationData.method,
				'Database': mongoDatabaseService.mongoDatabaseData.mongoDatabaseModeName,
				'Drop': mongoDatabaseService.mongoDatabaseData.isDropCollection
			}, {
				'Time': time,
				'Current': currentItem,
				'Available': available,
				'Status': applicationService.applicationData.status
			}, {
				'Total': total,
				'Pending': pending,
				'Sent': sent,
				'Error': error,
				'Exists': exists,
				'Database': database
			}, {
				'Save': save,
				'Invalid': invalid,
				'Duplicate': duplicate,
				'Filter': filter,
				'Skip': skip,
				'Unsave': unsave,
				'Identical Addresses': identicalAddresses
			}, {
				'Monitor Sent': monitorSent,
				'Security Error': securityError,
				'Security Exists': securityExists,
				'Missing Field': missingField,
				'Invalid Status': invalidStatus
			}, {
				'Identical Status': identicalStatus,
				'Unexpected Field': unexpectedField,
				'Sent Error In A Row': sendErrorInARowCount,
				'Save Error In A Row': saveErrorInARowCount
			}, {
				'Id': accountsService.accountData.id,
				'Username': accountsService.accountData.username,
				'Sent': accountSentItem,
				'Accounts': accounts
			}, {
				'#': accountsService.accountData.apiKey
			}, {
				[`Subject (Id: ${subjectId})`]: subjectLineDisplay,
				[`Text (Id: ${textId})`]: textLineDisplay
			}, {
				'#': filePath
			}, {
				'Code': resultCode,
				'Status': status,
				'Step': step,
				'From': fromEmailAddress,
				'To': toEmailAddress,
				'Id': id,
				'Type': type
			}, {
				'#': resultDetails
			}],
			colorsLists: [
				[Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW],
				[Color.YELLOW, Color.YELLOW, Color.CYAN, Color.YELLOW],
				[Color.CYAN, Color.CYAN, Color.GREEN, Color.RED, Color.CYAN, Color.CYAN],
				[Color.GREEN, Color.RED, Color.CYAN, Color.CYAN, Color.CYAN, Color.RED, Color.CYAN],
				[Color.CYAN, Color.RED, Color.RED, Color.RED, Color.RED],
				[Color.RED, Color.RED, Color.RED, Color.RED, Color.RED],
				[Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW],
				[],
				[Color.YELLOW, Color.YELLOW],
				[],
				[Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW, Color.YELLOW],
				[]
			],
			statusColor: Color.CYAN
		});
	}

	createEmailTemplate(emailData, isLog) {
		const { id, accountId, accountApiKey, fromEmailAddress, toEmailAddress, subjectId, subjectLine, subjectLineDisplay,
			textId, textLine, textLineDisplay, status, step, type, resultDateTime, resultDetails, resultCode } = emailData;
		const time = timeUtils.getFullTime(resultDateTime);
		const displayStatus = this.getDisplayStatus(status);
		let displayFromEmailAddress, displayToEmailAddress, subject, text = null;
		if (isLog) {
			displayFromEmailAddress = fromEmailAddress;
			displayToEmailAddress = toEmailAddress;
			subject = subjectLine;
			text = textLine;
		}
		else {
			displayFromEmailAddress = this.getDisplayEmailAddress(fromEmailAddress);
			displayToEmailAddress = this.getDisplayEmailAddress(toEmailAddress);
			subject = subjectLineDisplay;
			text = textLineDisplay;
		}
		const displayResultDetails = resultDetails.join('\n');
		const lines = [];
		lines.push(`Time: ${time} | Code: ${resultCode} | Status: ${displayStatus} | Step: ${step} | Type: ${type}`);
		lines.push(`From: ${displayFromEmailAddress} | To: ${displayToEmailAddress} | Email Id: ${id} | Account Id: ${accountId}`);
		lines.push(`API Key: ${accountApiKey}`);
		lines.push(`Subject (Id: ${subjectId}): ${subject} | Text (Id: ${textId}): ${text}`);
		lines.push(`Result: ${displayResultDetails}`);
		lines.push(`${this.logSeperator}${isLog ? '\n' : ''}`);
		return lines.join('\n');
	}

	async logResult(emailData) {
		if (!applicationService.applicationData.isLogResults) {
			return;
		}
		const message = this.createEmailTemplate(emailData, true);
		await fileUtils.appendFile({
			targetPath: this.emailResultsPath,
			message: message
		});
	}

	createConfirmSettingsTemplate(settings) {
		const parameters = ['IS_PRODUCTION_MODE', 'IS_SEND_EMAILS', 'IS_SAVE_EMAILS', 'IS_DROP_COLLECTION',
			'IS_SKIP_LOGIC', 'IS_MONITOR_LOGIC', 'IS_LOG_RESULTS', 'IS_LOG_MODE', 'MONITOR_EMAILS_SEND_COUNT',
			'MAXIMUM_SENDGRID_DAILY_EMAILS_COUNT'];
		let settingsText = this.createLineTemplate('DATABASE', mongoDatabaseUtils.getMongoDatabaseModeName(settings));
		settingsText += Object.keys(settings).filter(s => parameters.indexOf(s) > -1)
			.map(k => this.createLineTemplate(k, settings[k])).join('');
		settingsText = textUtils.removeLastCharacter(settingsText);
		return `${textUtils.setLogStatus('IMPORTANT SETTINGS')}
${settingsText}
========================
OK to run? y/n`;
	}

	close() {
		if (this.logInterval) {
			clearInterval(this.logInterval);
		}
	}
}

module.exports = new LogService(); */

/* Color,  */
//) {
                //systemUtils.exit(Status.PURCHASE_ERROR_IN_A_ROW, Color.RED, 0);
            //}
/*                 '--user-data-dir=C:/puppeteer/' */
            //ignoreDefaultArgs: ['--enable-automation'],
        //await globalUtils.sleep(3000); // Insert to settings.js. Different variable, Wait for course page to load.
        //await globalUtils.sleep(3000); // Insert to settings.js. Different variable, Wait for checkout page to load.
 // Insert to settings.js. Different variable, Wait for purchase success page to load.
 // Insert to settings.js. Different variable, Wait between each course.
/* Insert to settings.js */
        //const coursesList = courseService.coursesData.coursesList.filter(c => c.status === CourseStatus.CREATE);
/* Color, */
            //systemUtils.exit(Status.LOGOUT_FAILED, Color.RED, 0);
                    //await globalUtils.sleep(100000); // Insert to settings.js
                    //systemUtils.exit(Status.LOGIN_LOGIN_FAILED, Color.RED, 0);
            //systemUtils.exit(Status.LOGIN_LOAD_FAILED, Color.RED, 0);
            // Change course status to PURCHASE.
            // Change course status to FAIL.
            // Change course status to CHECKOUT_PRICE_NOT_FREE.
            // Change course status to CHECKOUT_PRICE_NOT_EXISTS.
            // Change course status to PURCHASE.
            // Change course status to ENROLL_NOT_EXISTS.
            // Change course status to COURSE_PRICE_NOT_FREE.
            // Change the status to ALREADY_PURCHASE.
            // Change the status to ALREADY_PURCHASE.
            // Change the status to SUGGESTIONS_LIST.
/*             // Change the status to LIMIT_ACCESS. */
/*             // Change the status to NOT_EXISTS. */
        //return page;
/*         if () */
        //const url = '';
                    //console.log('PURCHASE');
        //console.log('ALREADY_PURCHASE');
        //const element = await page.waitForSelector('a.cookie-close', { visible: true });
        //await element.click();
        //console.log(checkoutPrice);
        //console.log(await page.url());
        //console.log(checkoutPrice);
        //console.log('ENROLL_NOT_EXISTS');
        //console.log(courseOriginalPriceLabel);
        //document.querySelectorAll('[data-foo="value"]');
        //await enrollButton.click();
/*         const button = await enrollButton.$('a.marketing-button');
        button.click(); */
        //await page.waitForFunction(this.waitForFunction, { timeout: this.timeout });
        //await globalUtils.sleep(1000); // Insert to settings.js
        //debugger;
        //const enrollButton = await page.$eval(domService.courseEnrollButtonDOM);
/*         const enrollButton = page.$eval(domService.courseEnrollButtonDOM);
        if (!enrollButton) {
            // Change course status to ENROLL_NOT_EXISTS.
        } */
        //NOT_FOUND | LIMIT_ACCESS | ALREADY_PURCHASE | NOT_FREE
        //const span = await coursesPriceLabel[1].$eval('span', i => i.getProperty('textContent'));
        //const text = await (await span.getProperty('textContent')).jsonValue();
        //const text = await (await coursesPriceLabel[0].getProperty('textContent')).jsonValue();
        //const text = await page.evaluate(elm => elm.textContent, coursesPriceLabel[1]);
        //const text = await page.$eval(domService.coursePriceLabel, el => el.textContent);
        //console.log(text);
        //debugger;
        //await page.waitForNavigation(this.pageOptions);
        //await page.waitForNavigation(this.pageOptions);
        //debugger;
            //return;
/*             return; */
/* const { applicationData } = require('./application.service'); */
        //await page.$x('//a[contains(., "Log out")]')[0].click();
        //await globalUtils.sleep(10000); // Insert to settings.js
        //await this.close(browser);
        //await page.setUserAgent(crawlUtils.getRandomUserAgent());
/*         await page.setJavaScriptEnabled(isEnableJavaScript); */
/*         let emailDOM = null;
        if (await page.$(domService.loginEmail1DOM) !== null) {
            emailDOM = domService.loginEmail1DOM;
        } */
        //await globalUtils.sleep(10000000); // Insert to settings.js
/*         if (await page.url().indexOf('login') > -1) {
            //await page.setUserAgent(crawlUtils.getRandomUserAgent());
            await page.goto(applicationService.applicationData.udemyBaseURL, this.pageOptions);
            await page.waitForFunction(this.waitForFunction, { timeout: this.timeout });
        } */
        //        //console.log(await page.cookies());
/*         await Promise.all([
            page.click(domService.loginButtonDOM),
            page.waitForNavigation({ waitUntil: 'networkidle0' })
        ]); */
        //await page.click(domService.loginButtonDOM);
        //await page.waitForNavigation(this.pageOptions);
        //await page.waitForFunction(this.waitForFunction, { timeout: this.timeout });
/*         // Insert credentials and click login.
        await globalUtils.sleep(1000); // Insert to settings.js
        await page.$eval('#id_email', (el, value) => el.value = value, accountService.accountData.email);
        await globalUtils.sleep(1000); // Insert to settings.js
        await page.$eval('#id_password', (el, value) => el.value = value, accountService.accountData.password);
        await globalUtils.sleep(1000); // Insert to settings.js
        await this.close(browser); */

                    //if (await page.$('#id_email') === null || await page.$('#id_password') === null) {
        //console.log(accountService);
/*         (async () => {
            await page.evaluate(({List}) => {
               function sleep() {
                   return new Promise(r => setTimeout(r, 3000)).catch();
               }

               for (i = 0; i < y; i++) {
                   try {
                      getCurrentList(List[i])
                   } catch (error) { };
                   await sleep();
               }
           },{List});
        })(); */

//            console.log('close');
/*         browser.on('targetcreated', async () => {
    const pages = await browser.pages();
    if (pages.length > 1) {
        await pages[0].close();
        browser.off('targetcreated');
    }
}); */
            //systemUtils.killProcess(pid);
        //console.log(courseService.coursesData.coursesList);
        //console.log(posts);
            //course = domService.getPostUdemyLink(course, postContent);
/*             posts[i] = course; */
        //console.log(courseService);

            //await page.waitFor(this.millisecondsTimeoutBetweenMainPages);
/* const coursesService = require('./courses.service'); */
/* Move this to settings.js */
/*             if (validationUtils.isExists(posts)) {
                coursesService.updatedCourses(posts);
            } */
/*             const posts = domService.getPosts(mainContent);
            if (validationUtils.isExists(posts)) {
                coursesService.updatedCourses(posts);
            } */
/* const validationService = require('./validation.service'); */
/*             if (i === 0) {
                break;
            } */
/*         console.log(url); */
/* const puppeteerExtra = require('puppeteer-extra');
const pluginStealth = require('puppeteer-extra-plugin-stealth');
const { crawlUtils } = require('../../utils');
const systemUtils = require('../../utils/files/system.utils');
const { Color } = require('../../core/enums/files/text.enum');

class PuppeteerService {

    constructor() {
        this.browser = null;
        this.page = null;
        this.pageOptions = null;
        this.waitForFunction = null;
        this.isLinkCrawlTest = null;
        this.timeout = null;
        this.pid = null;
        this.errorInARowCounter = null;
    }

    async initiate(countLimitData, isLinkCrawlTest) {
        this.errorInARowCounter = 0;
        this.timeout = countLimitData.millisecondsTimeoutSourceRequestCount;
        this.pageOptions = {
            waitUntil: 'networkidle2',
            timeout: this.timeout
        };
        this.waitForFunction = 'document.querySelector("body")';
        puppeteerExtra.use(pluginStealth());
        this.browser = await puppeteerExtra.launch({
            headless: false,
            args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage'
            ]
        });
        this.pid = this.browser.process().pid;
        this.browser.on('disconnected', () => {
            systemUtils.killProcess(this.pid);
            systemUtils.exit('EXCEEDED THE LIMIT', Color.RED, 1);
        });
        this.page = await this.browser.newPage();
        await this.page.setRequestInterception(true);
        await this.page.setJavaScriptEnabled(false);
        await this.page.setDefaultNavigationTimeout(this.timeout);
        this.page.on('request', (request) => {
            if (['image', 'stylesheet', 'font', 'script'].indexOf(request.resourceType()) !== -1) {
                request.abort();
            } else {
                request.continue();
            }
        });
        this.page.on('dialog', async dialog => {
            await dialog.dismiss();
        });
        this.isLinkCrawlTest = isLinkCrawlTest;
    }

    async crawl(link, userAgent) {
        return await new Promise(async (resolve, reject) => {
            if (reject) { }
            // Limit the runtime of this function in case of stuck URL crawling process.
            const abortTimeout = setTimeout(async () => {
                try {
                    await this.page.reload(link, this.pageOptions);
                }
                catch (error) {
                    this.errorInARowCounter += 1;
                }
                resolve(null);
                return;
            }, this.timeout);
            if (!userAgent) {
                userAgent = crawlUtils.getRandomUserAgent();
            }
            const crawlResults = {
                isValidPage: true,
                pageSource: null
            };
            try {
                await this.page.setUserAgent(userAgent);
                await this.page.goto(link, this.pageOptions);
                await this.page.waitForFunction(this.waitForFunction, { timeout: this.timeout });
                crawlResults.pageSource = await this.page.content();
                this.errorInARowCounter = 0;
            }
            catch (error) {
                this.errorInARowCounter += 1;
                crawlResults.isValidPage = false;
            }
            if (this.isLinkCrawlTest) {
                await this.close();
            }
            clearTimeout(abortTimeout);
            resolve(crawlResults);
        }).catch();
    }

    async close() {
        if (this.browser) {
            try {
                await this.page.close();
                await this.browser.disconnect();
                await this.browser.close();
            }
            catch (error) {
                this.errorInARowCounter += 1;
            }
        }
    }
}

module.exports = new PuppeteerService();
/*                 '--single-process',
                '--no-zygote',
                '--no-sandbox', */

/* const puppeteerExtra = require('puppeteer-extra');
const pluginStealth = require('puppeteer-extra-plugin-stealth');
const accountService = require('./account.service');
const applicationService = require('./application.service');
const courseService = require('./course.service');
const countLimitService = require('./countLimit.service');
const domService = require('./dom.service');
const { crawlUtils, systemUtils } = require('../../utils');
const globalUtils = require('../../utils/files/global.utils');
const { Color, Status } = require('../../core/enums');

class PuppeteerService {

    constructor() {
        this.timeout = null;
        this.pageOptions = null;
        this.waitForFunction = null;
    }

    initiate() {
        puppeteerExtra.use(pluginStealth());
        this.timeout = countLimitService.countLimitData.millisecondsTimeoutSourceRequestCount;
        this.pageOptions = {
            waitUntil: 'networkidle2',
            timeout: this.timeout
        };
        this.waitForFunction = 'document.querySelector("body")';
    }

    async initiateCrawl(isDisableAsserts) {
        // Set the browser.
        const browser = await puppeteerExtra.launch({
            headless: false,
            args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage'
            ]
        });
        const pid = browser.process().pid;
        browser.on('disconnected', () => {
            systemUtils.killProcess(pid);
        });
        process.on('SIGINT', () => {
            this.close(browser);
        });
        // Set the page and close the first empty tab.
        const page = await browser.newPage();
        const pages = await browser.pages();
        if (pages.length > 1) {
            await pages[0].close();
        }
        await page.setUserAgent(crawlUtils.getRandomUserAgent());
        await page.setRequestInterception(true);
        await page.setJavaScriptEnabled(isDisableAsserts);
        await page.setDefaultNavigationTimeout(this.timeout);
        page.on('request', (request) => {
            if (isDisableAsserts && ['image', 'stylesheet', 'font', 'script'].indexOf(request.resourceType()) !== -1) {
                request.abort();
            } else {
                request.continue();
            }
        });
        return {
            browser: browser,
            page: page
        };
    }

    async createCourses() {
        const { browser, page } = await this.initiateCrawl(true);
        // Go to the courses from single URLs.
        for (let i = 1; i < countLimitService.countLimitData.maximumPagesNumber; i++) {
            const url = `${applicationService.applicationData.coursesBaseURL}/${applicationService.applicationData.coursesDate}/page/${i}/`;
            await page.goto(url, this.pageOptions);
            await page.waitForFunction(this.waitForFunction, { timeout: this.timeout });
            const mainContent = await page.content();
            // Get all the courses from the main page with pagination.
            if (!await domService.getSingleCourses(mainContent, i)) {
                break;
            }
            await globalUtils.sleep(countLimitService.countLimitData.millisecondsTimeoutBetweenCoursesMainPages);
        }
        await this.close(browser);
    }

    async updateCoursesData() {
        const { browser, page } = await this.initiateCrawl(true);
        // Loop on the course URL to get the course full data.
        const originalCoursesCount = courseService.coursesData.coursesList.length;
        for (let i = 0; i < originalCoursesCount; i++) {
            const course = courseService.coursesData.coursesList[i];
            await page.goto(course.courseURL, this.pageOptions);
            await page.waitForFunction(this.waitForFunction, { timeout: this.timeout });
            const postContent = await page.content();
            await domService.getCourseFullData({
                course: course,
                courseIndex: i,
                courseContent: postContent
            });
        }
        await this.close(browser);
    }

    async purchaseCourses() {
        const { browser, page } = await this.initiateCrawl(false);
        // Login to Udemy.
        let pageLoaded = false;
        for (let i = 0; i < 5 /* Insert to settings.js ; i++) {
            // If no match for the email or password inputs, the page usually go to
            // "Provie you are human" or "Your browser too old" pages. Change the user agent
            // and reload the page should solve this issue.
            if (await page.$(domService.loginEmailDOM) === null || await page.$(domService.loginPasswordDOM) === null) {
                await page.goto(applicationService.applicationData.udemyLoginURL, this.pageOptions);
                await page.waitForFunction(this.waitForFunction, { timeout: this.timeout });
            }
            else {
                pageLoaded = true;
                break;
            }
            if (!pageLoaded && i > 0) {
                await globalUtils.sleep(1000); // Insert to settings.js
                await page.setUserAgent(crawlUtils.getRandomUserAgent());
            }
        }
        // If pages didn't loaded after number of attempts to reload, exit the program.
        if (!pageLoaded) {
            await this.close(browser);
            systemUtils.exit(Status.LOGIN_PAGE_FAILED_TO_LOAD, Color.RED, 1);
            return;
        }
        // Insert credentials and click login.
        await globalUtils.sleep(1000); // Insert to settings.js
        await page.$eval(domService.loginEmailDOM, (el, value) => el.value = value, accountService.accountData.email);
        await globalUtils.sleep(1000); // Insert to settings.js
        await page.$eval(domService.loginPasswordDOM, (el, value) => el.value = value, accountService.accountData.password);
        await globalUtils.sleep(1000); // Insert to settings.js
        await page.click(domService.loginButtonDOM);
        console.log(await page.cookies());
        await page.waitForNavigation(this.pageOptions);
/*         await Promise.all([
            page.click(domService.loginButtonDOM),
            page.waitForNavigation({ waitUntil: 'networkidle0' })
        ]);
        //await page.click(domService.loginButtonDOM);
        //await page.waitForNavigation(this.pageOptions);
        //await page.waitForFunction(this.waitForFunction, { timeout: this.timeout });
        await globalUtils.sleep(10000000); // Insert to settings.js
        await this.close(browser);
    }

    async close(browser) {
        if (browser) {
            await browser.close();
        }
    }
}

module.exports = new PuppeteerService();
/*         // Insert credentials and click login.
        await globalUtils.sleep(1000); // Insert to settings.js
        await page.$eval('#id_email', (el, value) => el.value = value, accountService.accountData.email);
        await globalUtils.sleep(1000); // Insert to settings.js
        await page.$eval('#id_password', (el, value) => el.value = value, accountService.accountData.password);
        await globalUtils.sleep(1000); // Insert to settings.js
        await this.close(browser); */

                    //if (await page.$('#id_email') === null || await page.$('#id_password') === null) {
        //console.log(accountService);
/*         (async () => {
            await page.evaluate(({List}) => {
               function sleep() {
                   return new Promise(r => setTimeout(r, 3000)).catch();
               }

               for (i = 0; i < y; i++) {
                   try {
                      getCurrentList(List[i])
                   } catch (error) { };
                   await sleep();
               }
           },{List});
        })(); */

//            console.log('close');
/*         browser.on('targetcreated', async () => {
    const pages = await browser.pages();
    if (pages.length > 1) {
        await pages[0].close();
        browser.off('targetcreated');
    }
}); */
            //systemUtils.killProcess(pid);
        //console.log(courseService.coursesData.coursesList);
        //console.log(posts);
            //course = domService.getPostUdemyLink(course, postContent);
/*             posts[i] = course; */
        //console.log(courseService);

            //await page.waitFor(this.millisecondsTimeoutBetweenMainPages);
/* const coursesService = require('./courses.service'); */
/* Move this to settings.js */
/*             if (validationUtils.isExists(posts)) {
                coursesService.updatedCourses(posts);
            } */
/*             const posts = domService.getPosts(mainContent);
            if (validationUtils.isExists(posts)) {
                coursesService.updatedCourses(posts);
            } */
/* const validationService = require('./validation.service'); */
/*             if (i === 0) {
                break;
            } */
/*         console.log(url); */
/* const puppeteerExtra = require('puppeteer-extra');
const pluginStealth = require('puppeteer-extra-plugin-stealth');
const { crawlUtils } = require('../../utils');
const systemUtils = require('../../utils/files/system.utils');
const { Color } = require('../../core/enums/files/text.enum');

class PuppeteerService {

    constructor() {
        this.browser = null;
        this.page = null;
        this.pageOptions = null;
        this.waitForFunction = null;
        this.isLinkCrawlTest = null;
        this.timeout = null;
        this.pid = null;
        this.errorInARowCounter = null;
    }

    async initiate(countLimitData, isLinkCrawlTest) {
        this.errorInARowCounter = 0;
        this.timeout = countLimitData.millisecondsTimeoutSourceRequestCount;
        this.pageOptions = {
            waitUntil: 'networkidle2',
            timeout: this.timeout
        };
        this.waitForFunction = 'document.querySelector("body")';
        puppeteerExtra.use(pluginStealth());
        this.browser = await puppeteerExtra.launch({
            headless: false,
            args: [
                '--no-sandbox',
                '--disable-setuid-sandbox',
                '--disable-dev-shm-usage'
            ]
        });
        this.pid = this.browser.process().pid;
        this.browser.on('disconnected', () => {
            systemUtils.killProcess(this.pid);
            systemUtils.exit('EXCEEDED THE LIMIT', Color.RED, 1);
        });
        this.page = await this.browser.newPage();
        await this.page.setRequestInterception(true);
        await this.page.setJavaScriptEnabled(false);
        await this.page.setDefaultNavigationTimeout(this.timeout);
        this.page.on('request', (request) => {
            if (['image', 'stylesheet', 'font', 'script'].indexOf(request.resourceType()) !== -1) {
                request.abort();
            } else {
                request.continue();
            }
        });
        this.page.on('dialog', async dialog => {
            await dialog.dismiss();
        });
        this.isLinkCrawlTest = isLinkCrawlTest;
    }

    async crawl(link, userAgent) {
        return await new Promise(async (resolve, reject) => {
            if (reject) { }
            // Limit the runtime of this function in case of stuck URL crawling process.
            const abortTimeout = setTimeout(async () => {
                try {
                    await this.page.reload(link, this.pageOptions);
                }
                catch (error) {
                    this.errorInARowCounter += 1;
                }
                resolve(null);
                return;
            }, this.timeout);
            if (!userAgent) {
                userAgent = crawlUtils.getRandomUserAgent();
            }
            const crawlResults = {
                isValidPage: true,
                pageSource: null
            };
            try {
                await this.page.setUserAgent(userAgent);
                await this.page.goto(link, this.pageOptions);
                await this.page.waitForFunction(this.waitForFunction, { timeout: this.timeout });
                crawlResults.pageSource = await this.page.content();
                this.errorInARowCounter = 0;
            }
            catch (error) {
                this.errorInARowCounter += 1;
                crawlResults.isValidPage = false;
            }
            if (this.isLinkCrawlTest) {
                await this.close();
            }
            clearTimeout(abortTimeout);
            resolve(crawlResults);
        }).catch();
    }

    async close() {
        if (this.browser) {
            try {
                await this.page.close();
                await this.browser.disconnect();
                await this.browser.close();
            }
            catch (error) {
                this.errorInARowCounter += 1;
            }
        }
    }
}

module.exports = new PuppeteerService();
/*                 '--single-process',
                '--no-zygote',
                '--no-sandbox', */

                        //await courseService.finalizePurchaseCourses();
/* async finalizePurchaseCourses() {
    // Log all the course.
    for (let i = 0; i < this.coursesData.coursesList.length; i++) {
        const course = this.coursesData.coursesList[i];
        // Log the course.
        await logCourse({
            course: course,
            method: Method.PURCHASE_COURSES,
            isValid: course.status === CourseStatus.PURCHASE
        });
    }
} */

        //console.log(courseService.coursesData.totalPriceNumber);
/*             console.log(purchaseCoursesResult); */
/* const { validationUtils } = require('../../utils'); */
//urls
/* const { validationUtils } = require('../../utils'); */

        //const udemyService = require('./udemy.service');
                //const { coursesBaseURL, udemyBaseURL } = applicationService.applicationData;
        //const urls = [applicationService.applicationData.coursesBaseURL, udemyService.udemyData.udemyBaseURL];
//        const { coursesBaseURL, udemyBaseURL } = applicationService.applicationData;
            //isConnected = await this.isURLOnLine(url);
/*     isURLOnLine(url) {
        return new Promise(resolve => {
            try {
                const options = { method: 'HEAD', host: 'stackover.com', port: 80, path: '/' },
                    req = http.request(options, (r) => { resolve(true); });
                req.on('error', resolve(false)).end();
            }
            catch (error) {
                resolve(false);
            }
            /*             dns.lookup(url, (error) => {
                            console.log(error);
                            resolve(error ? false : true);
                        }); */
/*         }).catch();
    } */

    ///*const pathUtils = require('../utils/files/path.utils');*/

    //    debugger;
//const { courseUtils } = require('../utils');
/*     const value = courseUtils.getCoursePrices('₪0.00');
    console.log(value); */
//const { courseUtils } = require('../utils');
/*     const url = '';
    courseUtils.getCourseSingleData(url); */
/* const test = (dom) => {
    console.log(dom);
}; */

/*     const puppeteer = require('puppeteer');
    (async () => {
        const browser = await puppeteer.launch({ headless: false });
        const page = await browser.newPage();
        // Instructs the blank page to navigate a URL
        await page.goto('https://www.google.com/');
        const result = await page.evaluate(() => {
            // Have the 'document' object available here. I want evaluate it outside of this scope,
            // since i have here a lot of investigation of the DOM and i don't want to mess the puppeeter code here.
            // I can't call any outer function here.
        });
        await browser.close();

        // ==================
        // Today, Instead of this, I need to export all the HTML page,
        // and send it to external package like jsdom in other file:
        const jsdom = require('jsdom');
        const pageContent = await page.content();
        const dom = new jsdom.JSDOM(pageContent);
        const links = dom.window.document.querySelectorAll('div');
        // Rest of the long investigation here.

        //==================
        // What i need?
        const dom = await page.contentDOM();
        const links = dom.window.document.querySelectorAll('div');

    })(); */

/*     const puppeteer = require('puppeteer');


    (async () => {
        const browser = await puppeteer.launch({ headless: false });
        const page = await browser.newPage();


        // Instructs the blank page to navigate a URL
        await page.goto('https://www.oreilly.com/library/view/learning-web-design/9781449337513/ch04.html'); */

        // Fetches page's title
        //const bodyHandle = await page.$('body');
        //const html = await page.evaluate(body => body.innerHTML, bodyHandle);
        //console.log(html.document.get);
        //const aHandle = await page.evaluateHandle(() => document.body);
/*         await page.evaluateHandle(() => {
            const test = (dom) => {
                console.log(dom);
            };
            const element = document.getElementsByTagName('body');
            test(element);
            return element;
        }); */
/*         const result = await page.evaluate(() => {
            return document.querySelector('body');
        });
        debugger; */
        //console.log(result);

/*         let html_content = await page.evaluate(el => el.innerHTML, await page.$('body'));
        console.log(html_content);

        await browser.close(); */
/*     })(); */

/* const { CourseStatus } = require('../core/enums');
const list = [{
    id: 1,
    url: 'https://www.udemy.com/1dfs-df-sdf-s-df-s-d-b-tb-rt--rtn/',
    status: CourseStatus.ERROR
}, {
    id: 2,
    url: 'https://www.udemy.com/sdfsdfdsf/',
    status: CourseStatus.CREATE
}, {
    id: 3,
    url: 'https://www.udemy.com/bgf-reg-d-fsdf-dfs/',
    status: CourseStatus.ERROR
}, {
    id: 4,
    url: 'https://www.udemy.com/1dfs-df-sdf-s-df-s-d-b-tb-rt--rtn/',
    status: CourseStatus.ERROR
}, {
    id: 5,
    url: 'https://www.udemy.com/nhg-ds-vbfd-gf-fdfg/',
    status: CourseStatus.CREATE
}, {
    id: 6,
    url: 'https://www.udemy.com/bgf-reg-d-fsdf-dfs/',
    status: CourseStatus.ERROR
}, {
    id: 7,
    url: 'https://www.udemy.com/1dfs-df-sdf-s-df-s-d-b-tb-rt--rtn/',
    status: CourseStatus.ERROR
}, {
    id: 8,
    url: 'https://www.udemy.com/gbf-re-df-gd-fgd-/',
    status: CourseStatus.CREATE
}, {
    id: 9,
    url: 'https://www.udemy.com/bgf-reg-d-fsdf-dfs/',
    status: CourseStatus.CREATE
}, {
    id: 10,
    url: 'https://www.udemy.com/1dfs-df-sdf-s-df-s-d-b-tb-rt--rtn/',
    status: CourseStatus.ERROR
}];

for (let y = 0; y < list.length; y++) {
    const currentURL = list[y];
    if (currentURL.status !== CourseStatus.CREATE) {
        continue;
    }
    for (let i = 0; i < list.length; i++) {
        const { id, status, url } = list[i];
        if (currentURL.id === id || status !== CourseStatus.CREATE) {
            continue;
        }
        if (currentURL.url === url) {
            list[i].status = CourseStatus.DUPLICATE;
        }
    }
}
console.log(list); */

/*     '',
    'https://www.udemy.com/course/how-to-make-a-wordpress-website-2020/?ranMID=39197&ranEAID=nN98ER4vNAU&ranSiteID=nN98ER4vNAU-INFOBoLMDlkm9sqEDRocaw&utm_source=aff-campaign&utm_medium=udemyads&LSNPUBID=nN98ER4vNAU',
    'https://www.udemy.com/course/certificated-course-in-marketing/?ranMID=39197&ranEAID=nN98ER4vNAU&ranSiteID=nN98ER4vNAU-3XHvb4RLM5NclxAmZUHuhQ&utm_source=aff-campaign&LSNPUBID=nN98ER4vNAU&utm_medium=udemyads&couponCode=MARKETINGFREE0',
    'https://www.udemy.com/topic/public-speaking/?LSNPUBID=nN98ER4vNAU&couponCode=SMHMAWEXPOCT212020&ranEAID=nN98ER4vNAU&ranMID=39197&ranSiteID=nN98ER4vNAU-8Km9soMYpE.1oEcpg4dRog&utm_medium=udemyads&utm_source=aff-campaign',
    'https://www.udemy.com/course/use-webflow-to-build-your-web-design-business/?ranMID=39197&ranEAID=nN98ER4vNAU&ranSiteID=nN98ER4vNAU-IOQ3BOfhmWYXKdvtaxBWUQ&utm_source=aff-campaign&utm_medium=udemyads&LSNPUBID=nN98ER4vNAU',
    'https://www.udemy.com/course/write-mindfully/?couponCode=04E2D8EB19BCDF327F45&ranMID=39197&ranEAID=nN98ER4vNAU&ranSiteID=nN98ER4vNAU-BfKqs3NosATc6yZiY4c4wQ&LSNPUBID=nN98ER4vNAU&utm_source=aff-campaign&utm_medium=udemyads' */

/*     'https://www.udemy.com/course/storybook/?couponCode=12qw1&ranMID=39197&ranEAID=nN98ER4vNAU&ranSiteID=nN98ER4vNAU-YrmA2.1D4xjhYR.._pj_Xw&utm_source=aff-campaign&utm_medium=udemyads&LSNPUBID=nN98ER4vNAU' */

    /* 'https://www.udemy.com/course/quickbooks-desktop-vs-sage-50cloud-accounting-2020/?ranMID=39197&ranEAID=nN98ER4vNAU&ranSiteID=nN98ER4vNAU-x8solmIDlx6MkejoR3nQ3g&utm_source=aff-campaign&utm_medium=udemyads&LSNPUBID=nN98ER4vNAU&couponCode=399B30450CABC886EBA3' */

    //'https://www.udemy.com/course/quickbooks-/'

    /*     'https://www.udemy.com/course/java-programming-complete-beginner-to-advanced-from-scratch/?couponCode=FREE_NOV' */
    /*     // SUGGESTIONS LIST
        'https://www.udemy.com/topic/digital-nomad/?LSNPUBID=nN98ER4vNAU&couponCode=DMTMCEXPOCT212020&ranEAID=nN98ER4vNAU&ranMID=39197&ranSiteID=nN98ER4vNAU-xEQZTLnvcfDdImKQ4VHpkw&utm_medium=udemyads&utm_source=aff-campaign',
        // SUGGESTIONS LIST
        'https://www.udemy.com/topic/public-speaking/?LSNPUBID=nN98ER4vNAU&couponCode=SMHMAWEXPOCT212020&ranEAID=nN98ER4vNAU&ranMID=39197&ranSiteID=nN98ER4vNAU-8Km9soMYpE.1oEcpg4dRog&utm_medium=udemyads&utm_source=aff-campaign', */
    //'https://www.udemy.com/course/use-webflow-to-build-your-web-design-business/?ranMID=39197&ranEAID=nN98ER4vNAU&ranSiteID=nN98ER4vNAU-IOQ3BOfhmWYXKdvtaxBWUQ&utm_source=aff-campaign&utm_medium=udemyads&LSNPUBID=nN98ER4vNAU'
    //'https://www.udemy.com/course/write-mindfully/?couponCode=04E2D8EB19BCDF327F45&ranMID=39197&ranEAID=nN98ER4vNAU&ranSiteID=nN98ER4vNAU-BfKqs3NosATc6yZiY4c4wQ&LSNPUBID=nN98ER4vNAU&utm_source=aff-campaign&utm_medium=udemyads'

    /*  // ALREADY PURCHASE
        'https://www.udemy.com/course/quickbooks-desktop-vs-sage-50cloud-accounting-2020/?ranMID=39197&ranEAID=nN98ER4vNAU&ranSiteID=nN98ER4vNAU-x8solmIDlx6MkejoR3nQ3g&utm_source=aff-campaign&utm_medium=udemyads&LSNPUBID=nN98ER4vNAU&couponCode=399B30450CABC886EBA3', */
    // PURCHASE - FREE
    //'https://www.udemy.com/course/research-methods-using-gorilla/',
    /*     // NOT FREE
        'https://www.udemy.com/course/facebook-ads-marketing-hindi-urdu-targeting-strategies-2021-2022-2020/',
        // LIMIT ACCESS
        'https://www.udemy.com/course/java-programming-complete-beginner-to-advanced-from-scratch/?couponCode=FREE_NOV' */

        /* characterUtils,  */
/* const characterUtils = require('./files/character.utils'); */

/*     updateCourseStatus(data) {
        const { course, status, details } = data;
        course.status = status;
        course.resultDateTime = new Date();
        course.resultDetails.push(details);
        return course;
    } */
//        console.log(url);
//        debugger;
/*         const { resultDateTime, resultDetails } = course;
        if (resultDateTime || resultDetails) {
            throw new Error(`Course status override. Exists: ${course.status} | New: ${status}.`);
        } */
/*         const { resultDateTime, resultDetails } = course;
        if (resultDateTime || resultDetails) {
            return;
        } */
/*         const couponKey = url.split('couponCode=')[1]; */
        //console.log(couponKey);


    /*
const globalUtils = require('../../utils/files/global.utils'); */

    /*

        // This method remove all files from a given target path.
        async emptyDirectory(targetPath) {
            // Verify that the path exists.
            globalUtils.isPathExistsError(targetPath);
            // Empty the directory.
            await fs.emptyDir(targetPath);
        }

        // This method return all the files in a given target path.
        async getDirectoryFiles(targetPath) {
            // Verify that the path exists.
            globalUtils.isPathExistsError(targetPath);
            // Get all the files.
            return await fs.readdir(targetPath);
        }

        async readFile(targetPath) {
            // Verify that the path exists.
            globalUtils.isPathExistsError(targetPath);
            // Return the file content.
            return await this.read(targetPath);
        }

        async removeFile(targetPath) {
            // Verify that the path exists.
            globalUtils.isPathExistsError(targetPath);
            // Remove the file.
            await fs.unlink(targetPath);
        }

        async removeFileIfExists(targetPath) {
            // Check if the file exists.
            if (await this.isPathExists(targetPath)) {
                // Remove it.
                await fs.unlink(targetPath);
            }
        }

        async getFilesRecursive(directory) {
            const dirents = await fs.readdir(directory, { withFileTypes: true });
            const files = await Promise.all(dirents.map(dirent => {
                const result = pathUtils.resolve(directory, dirent.name);
                return dirent.isDirectory() ? this.getFilesRecursive(result) : result;
            }));
            return Array.prototype.concat(...files);
        } */

        /*
const path = require('path'); */


    /*

        deleteDirectoryRecursive(directoryPath) {
            if (fs.existsSync(directoryPath)) {
                fs.readdirSync(directoryPath).forEach(file => {
                    const curPath = path.join(directoryPath, file);
                    if (fs.lstatSync(curPath).isDirectory()) { // Recursive.
                        this.deleteDirectoryRecursive(curPath);
                    } else { // Delete file.
                        fs.unlinkSync(curPath);
                    }
                });
                fs.rmdirSync(directoryPath);
            }
        }

        updateFile(targetPath, file) {
            fs.writeFileSync(targetPath, JSON.stringify(file, null, 2));
        }

        deleteFile(targetPath) {
            fs.unlinkSync(targetPath);
        }*/



    /*


        logStatus(status, object) {
            if (!status) {
                return;
            }
            this.log(textUtils.setLogStatus(status));
            if (object) {
                this.log(object);
            }
        }



        logSchedule(text) {
            text = textUtils.setLogStatus(text);
            text = this.logColor(text, Color.MAGENTA);
            logUpdate(text);
        } */

            /*
const textUtils = require('./text.utils'); */

/*     // This method check if a given file is in a given extension.
    isTypeFile(data) {
        const { fileName, fileExtension } = data;
        // Check if the fileName parameter was received.
        if (!fileName) {
            throw new Error(`fileName not received: ${fileName} (1000032)`);
        }
        // Check if the fileExtension parameter was received.
        if (!fileExtension) {
            throw new Error(`fileExtension not received: ${fileExtension} (1000033)`);
        }
        const extension = path.extname(fileName);
        // Check if the extension parameter was received.
        if (!extension) {
            throw new Error(`extension not received: ${extension} (1000034)`);
        }
        return textUtils.toLowerCase(extension) === textUtils.addStartDot(textUtils.toLowerCase(fileExtension));
    }

    resolve(directory, direntName) {
        return path.resolve(directory, direntName);
    } */

    /* 	createRegex(regex) {
		return new RegExp(regex);
	} */
/* 		this.commonTypos = [{
			pattern: /,com$/,
			fix: str => str.replace(/,com$/, '.com')
		}, {
			pattern: /,co\.\w{2}$/,
			fix: str => str.replace(/,(co\.\w{2}$)/, '.$1')
		}, {
			pattern: /@\w*$/,
			fix: str => str + '.com'
		}];
		this.detectLetter = /[a-zA-Z]/;
		this.findPackageNameRegex = /^[0-9^.v]*$/g;
		this.cleanAtRegex = /@/g;
		this.cleanSpacesRegex = /\s/g;
		this.cleanAllNoneAlphaNumericRegex = /[^\w.]/gi;
		this.cleanDomainPartRegex = /[^a-zA-Z0-9.-]/g;
		this.cleanLocalPartRegex = /[\\()",:@;<>\[\]]/g;
		this.englishCharactersRegex = /^[a-zA-Z\\-]+$/;
		this.numberCommasRegex = /\B(?=(\d{3})+(?!\d))/g;
		this.findEmailAddressesRegex = /([a-zA-Z0-9._-]+@[a-zA-Z0-9._-]+\.[a-zA-Z0-9._-]+)/gi;
		this.findURLRegex = /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b([-a-zA-Z0-9()@:%_\+.~#?&//=]*)?/gi;
		this.mongoConnectionStringRegex = new RegExp('^(mongodb:\/{2})localhost:(\d*)\/?(.*)');
		this.cleanMultiDots = new RegExp('([.])(?=\\1{1})', 'g'); */


        //newVal.replace(/[^0-9.]/g, "");
/*

/* const colorUtils = require('./color.utils');
const regexUtils = require('./regex.utils');

reverseText(text) {
    return text.split('').reverse().join('');
}

upperCaseFirstLetter(text, index) {
    return index === 0 ? this.toUpperCase(text.slice(0, 1)).concat(text.slice(1)) : text;
}

getRandomKeyFromArray(list) {
    if (!validationUtils.isExists(list)) {
        return '';
    }
    return list[Math.floor(Math.random() * list.length)];
}

getRandomUniqueKeysFromArray(list, itemsCount) {
    if (list.length === itemsCount) {
        return list;
    }
    const numbersList = [];
    const resultList = [];
    for (let i = 0; i < 20; i++) {
        const number = this.getRandomNumber(0, list.length);
        if (numbersList.indexOf(number) === -1) {
            numbersList.push(number);
            resultList.push(list[number]);
            if (resultList.length >= itemsCount) {
                break;
            }
        }
    }
    return resultList;
}

getRandomNumber(min, max) {
    return min + Math.floor((max - min) * Math.random());
}

getRandomBoolean() {
    return Math.random() >= 0.5;
}

isEnglishKey(key) {
    return regexUtils.englishCharactersRegex.test(key);
}

isCharacterALetter(character) {
    return regexUtils.detectLetter.test(character);
}

checkExistence(list, target) {
    if (!validationUtils.isExists(list)) {
        return false;
    }
    return list.filter(t => target.indexOf(t) > -1).length > 0;
}

removeDuplicates(list) {
    if (!validationUtils.isExists(list)) {
        return [];
    }
    return Array.from(new Set(list));
}

replaceAt(data) {
    const { text, position, newText } = data;
    if (!text) {
        return '';
    }
    return [text.substr(0, position), newText, text.substr(position + 1)].join('');
}

removeEmptySpaces(text) {
    if (!text) {
        return '';
    }
    return text.replace(regexUtils.cleanSpacesRegex, '');
}

removeFirstCharacter(text) {
    if (!text) {
        return '';
    }
    return text.substr(1);
}

removeLastCharacter(text) {
    if (!text) {
        return '';
    }
    return text.substring(0, text.length - 1);
}

removeLastCharacterLoop(data) {
    let { text, character } = data;
    if (!text) {
        return '';
    }
    for (let i = 0; i < 10; i++) {
        if (text.charAt(text.length - 1) === character) {
            text = this.removeLastCharacter(text);
        }
        else {
            break;
        }
    }
    return text;
}

removeLastCharacterNotALetterLoop(text) {
    if (!text) {
        return '';
    }
    for (let i = 0; i < 10; i++) {
        if (!this.isCharacterALetter(text.charAt(text.length - 1))) {
            text = this.removeLastCharacter(text);
        }
        else {
            break;
        }
    }
    return text;
}

removeFirstCharacterLoop(data) {
    let { text, character } = data;
    if (!text) {
        return '';
    }
    for (let i = 0; i < 10; i++) {
        if (text.charAt(0) === character) {
            text = this.removeFirstCharacter(text);
        }
        else {
            break;
        }
    }
    return text;
}

getSplitDotParts(text) {
    if (!text) {
        return '';
    }
    return text.split('.');
}

replaceCharacter(text, origin, target) {
    if (!text) {
        return '';
    }
    return text.replace(regexUtils.createRegex(origin), target);
}

toUpperCase(text) {
    if (!text) {
        return '';
    }
    return text.toUpperCase();
}

sliceJoinDots(array, number) {
    return array.slice(number).join('.');
}

addStartDot(text) {
    return `.${text}`;
}

addMiddleDot(text1, text2) {
    return `${text1}.${text2}`;
}

replaceLast(text, charecter, replace) {
    const a = text.split('');
    a[text.lastIndexOf(charecter)] = replace;
    return a.join('');
}

getObjectKeyValues(obj) {
    let result = '';
    const keys = Object.keys(obj);
    for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        const value = obj[key];
        result += `${this.upperCaseFirstLetter(key, 0)}: ${value} | `;
    }
    result = this.removeLastCharacters({
        value: result,
        charactersCount: 3
    });
    return result;
}

flipDotParts(text) {
    return text.split('.').reverse().join('.');
}

isCharactersEqual(text) {
    if (text.length === 1) {
        return true;
    }
    for (let i = 1; i < text.length; i++) {
        if (text[i] !== text[0]) {
            return false;
        }
    }
    return true;
} */

/*
            time: `${days}.${hours}:${minutes}:${seconds}`,
            minutes: parseInt(totalTime / 60000)
        };

const validationUtils = require('./validation.utils'); */

//12/08/2020 15:04:34

/*



    getRemainingTime(endDateTime) {
        const now = new Date().getTime();
        const timeleft = endDateTime - now;
        const days = textUtils.getFloorPositiveNumber(timeleft / (1000 * 60 * 60 * 24));
        const hours = textUtils.getFloorPositiveNumber((timeleft % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
        const minutes = textUtils.getFloorPositiveNumber((timeleft % (1000 * 60 * 60)) / (1000 * 60));
        const seconds = textUtils.getFloorPositiveNumber((timeleft % (1000 * 60)) / 1000);
        return {
            timeleft: timeleft,
            time: `${days}.${hours}:${minutes}:${seconds}`
        };
    } */
        //console.log(split);


    /*
        isDefined(variable) {
            return typeof variable !== 'undefined';
        }

        isValidDate(dateTime) {
            return dateTime instanceof Date;
        }

        // This method validates that a given string exists in array list of specific types.
        isValidEnum(data) {
            // Validate the existence and validity of the validateEnumData parameters. If not exists, return false.
            if (!data || !data.enum || !data.value) {
                return false;
            }
            // Check if the value exists within a given array. Return false if not.
            return Object.values(data.enum).indexOf(data.value) > -1;
        }

        isValidVersion(text) {
            if (!text) {
                return false;
            }
            return regexUtils.findPackageNameRegex.test(text);
        } */

            //const { textUtils } = require('../utils');
/*     const number = textUtils.getNumber2CharactersAfterDot(5468.599999999999);
    console.log(number); */

        //const { courseUtils } = require('../utils');
    //courseUtils.getCoursePrices('');